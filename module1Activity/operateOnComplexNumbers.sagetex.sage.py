## -*- encoding: utf-8 -*-


# This file was *autogenerated* from the file operateOnComplexNumbers.sagetex.sage
from sage.all_cmdline import *   # import sage library

_sage_const_24 = Integer(24); _sage_const_1 = Integer(1); _sage_const_0 = Integer(0); _sage_const_2 = Integer(2); _sage_const_11 = Integer(11); _sage_const_4 = Integer(4); _sage_const_3 = Integer(3); _sage_const_73 = Integer(73); _sage_const_77 = Integer(77); _sage_const_79 = Integer(79); _sage_const_82 = Integer(82)## This file (operateOnComplexNumbers.sagetex.sage) was *autogenerated* from operateOnComplexNumbers.tex with sagetex.sty version 2019/01/09 v3.2.
import sagetex
_st_ = sagetex.SageTeXProcessor('operateOnComplexNumbers', version='2019/01/09 v3.2', version_check=True)
_st_.current_tex_line = _sage_const_24 
_st_.blockbegin()
try:
 import random
 import cmath
 from sympy import *
 #
 # Takes in a rational value and multiplies it by either 1 or -1.
 def maybeMakeNegative(rational):
     maybeNegative = int((-_sage_const_1 )**random.randint(_sage_const_0 , _sage_const_1 ))
     rational = maybeNegative * rational
     return rational
 # Module 1 - Real & Complex Numbers
 # Objective - Multiply two complex numbers.
 
 ### DEFINITIONS ###
 def generateProblemCoefficients():
     listIntegers = range(_sage_const_2 , _sage_const_11 )
     constants = random.sample(listIntegers, _sage_const_4 )
     constants = [maybeMakeNegative(i) for i in constants]
     a1, b1, a2, b2 = constants
     while (a1*b2 + b1*a2) == _sage_const_0 :
         constants = random.sample(listIntegers, _sage_const_4 )
         constants = [maybeMakeNegative(i) for i in constants]
         a1, b1, a2, b2 = constants
     return constants
 def generateSolutionAndDistractors(coefficients):
     a1, b1, a2, b2 = coefficients
     complex1 = complex(a1, b1)
     complex2 = complex(a2, b2)
     product = complex1*complex2
     solution = [int(product.real), int(product.imag)]
     distractor1Product = complex(a1, -b1)*complex(a2, b2)
     distractor1 = [int(distractor1Product.real), int(distractor1Product.imag)]
     distractor2Product = complex(a1, b1)*complex(a2, -b2)
     distractor2 = [int(distractor2Product.real), int(distractor2Product.imag)]
     distractor3Product = complex(a1, -b1)*complex(a2, -b2)
     distractor3 = [int(distractor3Product.real), int(distractor3Product.imag)]
     distractor4Product = complex(a1*a2, b1*b2)
     distractor4 = [int(distractor4Product.real), int(distractor4Product.imag)]
     return [solution, distractor1, distractor2, distractor3, distractor4]
 
 ### VARIABLE DECLARATIONS ###
 problemCoefficients = generateProblemCoefficients()
 solutionList = generateSolutionAndDistractors(problemCoefficients)
 
 ### DEFINE XRONOS VARIABLES ###
 xronosSolution = solutionList[_sage_const_0 ]
 xronosDistractors = [solutionList[_sage_const_1 ], solutionList[_sage_const_2 ], solutionList[_sage_const_3 ], solutionList[_sage_const_4 ]]
 displayXronosStem = "Simplify the expression below into the form $a+bi$."
 xronosHint="You can treat $i$ as a variable and distribute. Just remember that $i^2=-1$, so you can continue to reduce after you distribute."
except:
 _st_.goboom(_sage_const_73 )
_st_.blockend()
try:
 _st_.current_tex_line = _sage_const_77 
 _st_.inline(_sage_const_0 , latex(displayXronosStem))
except:
 _st_.goboom(_sage_const_77 )
try:
 _st_.current_tex_line = _sage_const_79 
 _st_.inline(_sage_const_1 , latex(xronosSolution[_sage_const_0 ]))
except:
 _st_.goboom(_sage_const_79 )
try:
 _st_.current_tex_line = _sage_const_79 
 _st_.inline(_sage_const_2 , latex(xronosSolution[_sage_const_1 ]))
except:
 _st_.goboom(_sage_const_79 )
try:
 _st_.current_tex_line = _sage_const_82 
 _st_.inline(_sage_const_3 , latex(xronosHint))
except:
 _st_.goboom(_sage_const_82 )
_st_.endofdoc()

